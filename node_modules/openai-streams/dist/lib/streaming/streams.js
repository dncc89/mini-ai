import{ENCODER as i,DECODER as c}from"../../globs/shared.js";import{ChatParser as h,TokenParser as y}from"./transforms.js";import{createParser as l}from"eventsource-parser";import{pipeline as d,yieldStream as A}from"yield-stream";import{OpenAIError as k}from"../errors.js";const m=(o,{mode:t="tokens",onDone:s})=>new ReadableStream({async start(e){const f=l(async a=>{if(a.type==="event"){const{data:n}=a;if(n==="[DONE]"){e.desiredSize===null||e.close(),await s?.();return}try{const r=JSON.parse(n);if(e.enqueue(i.encode(n)),t==="tokens"&&r?.choices){const{choices:S}=r;for(const O of S)if(O?.finish_reason==="length")throw new k("MAX_TOKENS")}}catch(r){e.error(r)}}});for await(const a of A(o)){const n=c.decode(a);try{const r=JSON.parse(n);r.hasOwnProperty("error")&&e.error(new Error(r.error.message))}catch{}f.feed(n)}}}),p=({onParse:o})=>async function*(s){const e=c.decode(s);o?.(e),e&&(yield i.encode(e))},x=(o,t={mode:"tokens"})=>d(m(o,t),y,p(t)),v=(o,t={mode:"tokens"})=>d(m(o,t),h,p(t));export{v as ChatStream,m as EventStream,x as TokenStream};
